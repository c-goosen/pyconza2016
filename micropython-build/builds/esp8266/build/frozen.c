#include <stdint.h>
const char mp_frozen_str_names[] = {
"dht.py\0"
"main.py\0"
"neopixel.py\0"
"apa102.py\0"
"websocket_helper.py\0"
"port_diag.py\0"
"inisetup.py\0"
"ntptime.py\0"
"boot.py\0"
"\0"};
const uint32_t mp_frozen_str_sizes[] = {
794,
2976,
840,
846,
1624,
992,
1267,
879,
19,
};
const char mp_frozen_str_content[] = {
"# DHT11/DHT22 driver for MicroPython on ESP8266\n# MIT license; Copyright (c) 2016 Damien P. George\n\nimport esp\n\nclass DHTBase:\n    def __init__(self, pin):\n        self.pin = pin\n        self.buf = bytearray(5)\n\n    def measure(self):\n        buf = self.buf\n        esp.dht_readinto(self.pin, buf)\n        if (buf[0] + buf[1] + buf[2] + buf[3]) & 0xff != buf[4]:\n            raise Exception(\"checksum error\")\n\nclass DHT11(DHTBase):\n    def humidity(self):\n        return self.buf[0]\n\n    def temperature(self):\n        return self.buf[2]\n\nclass DHT22(DHTBase):\n    def humidity(self):\n        return (self.buf[0] << 8 | self.buf[1]) * 0.1\n\n    def temperature(self):\n        t = ((self.buf[2] & 0x7f) << 8 | self.buf[3]) * 0.1\n        if self.buf[2] & 0x80:\n            t = -t\n        return t\n\0"
"import network, esp, socket, machine, ure, ubinascii, bmp180\nfrom machine import Pin, I2C\nfrom bmp180 import BMP180\ndef wifiAP():\n    ap_if = network.WLAN(network.AP_IF)\n    essid = b\"MicroPython-%s\" % ubinascii.hexlify(ap_if.config(\"mac\")[-3:])\n    ap_if.config(essid=essid, authmode=network.AUTH_WPA_WPA2_PSK, password=b\"micropythoN\")\ndef connect_to_wifi():\n    wlan = network.WLAN(network.STA_IF) \n    wlan.active(True)       \n    wlan.isconnected()     \n    wlan.connect('cg', 'voss123456',timeout=100) \n    wlan.config('mac')     \n    print (\"Check if internet Connected\")\n    addr = socket.getaddrinfo('za.pycon.org', 80)[0][-1]\n\ndef web_server():\n    try:\n        pins = [machine.Pin(i, machine.Pin.OUT) for i in (0, 2, 4, )]\n        #pins.extend([machine.Pin(i, machine.Pin.IN) for i in (5, 12, 13, 14, 15)])\n        [p.low() for p in pins]\n        html = \"\"\"<!DOCTYPE html><html>\n            <head> <title>PyConZA IOT Demo</title> </head>\n            <body> <h1>PyConZA IOT Demo</h1> <h2>BMP Sensor Output</h2>\n                    <h2>Temp: %s</h2><h2>Pressure: %s</h2><h2>Altitude: %s</h2>\n            <h1>ESP8266 Pins</h1>\n                <table border=\"1\"> <tr><th>Pin</th><th>Value</th><th>Change Value</th></tr> %s </table>\n            </body>\n        </html>\n        \"\"\"\n        addr = socket.getaddrinfo('0.0.0.0', 80)[0][-1]\n        s = socket.socket()\n        s.bind(addr)\n        s.listen(5)\n        print('listening on', addr)\n        while True:\n            i2c = I2C(scl=Pin(14), sda=Pin(12))\n            bmp180 = BMP180(i2c)\n            bmp180.oversample_sett = 2\n            bmp180.baseline = 101325\n            temp = bmp180.temperature\n            pressure = bmp180.pressure\n            altitude = bmp180.altitude\n            print (\"Temp: %s Pressure: %s Altitude: %s\" %(temp,pressure,altitude))\n            conn, addr = s.accept()\n            print('client connected from', addr)\n            data = conn.recv(100)\n            if \"Pin\" in data:\n                r = str(data,'utf-8').split(\"/Pin(\")[1].split(\")\")[0]\n                print (\"Match \", r)\n                new_pin = machine.Pin(int(r))\n                if new_pin.value() == 1:\n                    new_pin.value(0)\n                    #new_pin.toggle()\n                    print (new_pin.value())\n                else:\n                    new_pin.value(1)\n            conn_file = conn.makefile('rwb', 0)\n            while True:\n                line = conn_file.readline()\n                if not line or line == b'\\r\\n':\n                    break\n                print (\"\")\n            rows = ['<tr><td>%s</td><td>%d</td><td><a href=\"http:/%s\"><button>Change</button></td></a></tr>' % (str(p), p.value(), str(p)) for p in pins]\n            response = html % (temp,pressure,altitude,'\\n'.join(rows))\n            conn.send(response)\n            conn.close()\n    except KeyboardInterrupt:\n        s.close()\n        print (\"Keyboard interrupt\")\ndef main():\n    wifiAP()\n    web_server()\nmain()\n\0"
"# NeoPixel driver for MicroPython on ESP8266\n# MIT license; Copyright (c) 2016 Damien P. George\n\nfrom esp import neopixel_write\n\nclass NeoPixel:\n    def __init__(self, pin, n):\n        self.pin = pin\n        self.n = n\n        self.buf = bytearray(n * 3)\n        self.pin.init(pin.OUT)\n\n    def __setitem__(self, index, val):\n        r, g, b = val\n        self.buf[index * 3] = g\n        self.buf[index * 3 + 1] = r\n        self.buf[index * 3 + 2] = b\n\n    def __getitem__(self, index):\n        i = index * 3\n        return self.buf[i + 1], self.buf[i], self.buf[i + 2]\n\n    def fill(self, color):\n        r, g, b = color\n        for i in range(len(self.buf) / 3):\n            self.buf[i * 3] = g\n            self.buf[i * 3 + 1] = r\n            self.buf[i * 3 + 2] = b\n\n    def write(self):\n        neopixel_write(self.pin, self.buf, True)\n\0"
"# APA102 driver for MicroPython on ESP8266\n# MIT license; Copyright (c) 2016 Robert Foss, Daniel Busch\n\nfrom esp import apa102_write\n\nclass APA102:\n    def __init__(self, clock_pin, data_pin, n):\n        self.clock_pin = clock_pin\n        self.data_pin = data_pin\n        self.n = n\n        self.buf = bytearray(n * 4)\n\n        self.clock_pin.init(clock_pin.OUT)\n        self.data_pin.init(data_pin.OUT)\n\n    def __setitem__(self, index, val):\n        r, g, b, brightness = val\n        self.buf[index * 4] = r\n        self.buf[index * 4 + 1] = g\n        self.buf[index * 4 + 2] = b\n        self.buf[index * 4 + 3] = brightness\n\n    def __getitem__(self, index):\n        i = index * 4\n        return self.buf[i], self.buf[i + 1], self.buf[i + 2], self.buf[i + 3]\n\n    def write(self):\n        apa102_write(self.clock_pin, self.data_pin, self.buf)\n\0"
"import sys\ntry:\n    import ubinascii as binascii\nexcept:\n    import binascii\ntry:\n    import uhashlib as hashlib\nexcept:\n    import hashlib\n\nDEBUG = 0\n\ndef server_handshake(sock):\n    clr = sock.makefile(\"rwb\", 0)\n    l = clr.readline()\n    #sys.stdout.write(repr(l))\n\n    webkey = None\n\n    while 1:\n        l = clr.readline()\n        if not l:\n            raise OSError(\"EOF in headers\")\n        if l == b\"\\r\\n\":\n            break\n    #    sys.stdout.write(l)\n        h, v = [x.strip() for x in l.split(b\":\", 1)]\n        if DEBUG:\n            print((h, v))\n        if h == b'Sec-WebSocket-Key':\n            webkey = v\n\n    if not webkey:\n        raise OSError(\"Not a websocket request\")\n\n    if DEBUG:\n        print(\"Sec-WebSocket-Key:\", webkey, len(webkey))\n\n    d = hashlib.sha1(webkey)\n    d.update(b\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")\n    respkey = d.digest()\n    respkey = binascii.b2a_base64(respkey)[:-1]\n    if DEBUG:\n        print(\"respkey:\", respkey)\n\n    sock.send(b\"\"\"\\\nHTTP/1.1 101 Switching Protocols\\r\nUpgrade: websocket\\r\nConnection: Upgrade\\r\nSec-WebSocket-Accept: \"\"\")\n    sock.send(respkey)\n    sock.send(\"\\r\\n\\r\\n\")\n\n\n# Very simplified client handshake, works for MicroPython's\n# websocket server implementation, but probably not for other\n# servers.\ndef client_handshake(sock):\n    cl = sock.makefile(\"rwb\", 0)\n    cl.write(b\"\"\"\\\nGET / HTTP/1.1\\r\nHost: echo.websocket.org\\r\nConnection: Upgrade\\r\nUpgrade: websocket\\r\nSec-WebSocket-Key: foo\\r\n\\r\n\"\"\")\n    l = cl.readline()\n#    print(l)\n    while 1:\n        l = cl.readline()\n        if l == b\"\\r\\n\":\n            break\n#        sys.stdout.write(l)\n\0"
"import esp\nimport uctypes\nimport network\nimport lwip\n\n\ndef main():\n\n    ROM = uctypes.bytearray_at(0x40200000, 16)\n    fid = esp.flash_id()\n\n    print(\"FlashROM:\")\n    print(\"Flash ID: %x (Vendor: %x Device: %x)\" % (fid, fid & 0xff, fid & 0xff00 | fid >> 16))\n\n    print(\"Flash bootloader data:\")\n    SZ_MAP = {0: \"512KB\", 1: \"256KB\", 2: \"1MB\", 3: \"2MB\", 4: \"4MB\"}\n    FREQ_MAP = {0: \"40MHZ\", 1: \"26MHZ\", 2: \"20MHz\", 0xf: \"80MHz\"}\n    print(\"Byte @2: %02x\" % ROM[2])\n    print(\"Byte @3: %02x (Flash size: %s Flash freq: %s)\" % (ROM[3], SZ_MAP.get(ROM[3] >> 4, \"?\"), FREQ_MAP.get(ROM[3] & 0xf)))\n    print(\"Firmware checksum:\")\n    print(esp.check_fw())\n\n    print(\"\\nNetworking:\")\n    print(\"STA ifconfig:\", network.WLAN(network.STA_IF).ifconfig())\n    print(\"AP ifconfig:\", network.WLAN(network.AP_IF).ifconfig())\n    print(\"Free WiFi driver buffers of type:\")\n    for i in range(5):\n        print(\"%d: %d\" % (i, esp.esf_free_bufs(i)))\n    print(\"lwIP PCBs:\")\n    lwip.print_pcbs()\n\n\nmain()\n\0"
"import uos\nimport network\nfrom flashbdev import bdev\n\ndef wifi():\n    import ubinascii\n    ap_if = network.WLAN(network.AP_IF)\n    essid = b\"MicroPython-%s\" % ubinascii.hexlify(ap_if.config(\"mac\")[-3:])\n    ap_if.config(essid=essid, authmode=network.AUTH_WPA_WPA2_PSK, password=b\"micropythoN\")\n\ndef check_bootsec():\n    buf = bytearray(bdev.SEC_SIZE)\n    bdev.readblocks(0, buf)\n    empty = True\n    for b in buf:\n        if b != 0xff:\n            empty = False\n            break\n    if empty:\n        return True\n    fs_corrupted()\n\ndef fs_corrupted():\n    import time\n    while 1:\n        print(\"\"\"\\\nFAT filesystem appears to be corrupted. If you had important data there, you\nmay want to make a flash snapshot to try to recover it. Otherwise, perform\nfactory reprogramming of MicroPython firmware (completely erase flash, followed\nby firmware programming).\n\"\"\")\n        time.sleep(3)\n\ndef setup():\n    check_bootsec()\n    print(\"Performing initial setup\")\n    wifi()\n    uos.VfsFat.mkfs(bdev)\n    vfs = uos.VfsFat(bdev, \"\")\n    with open(\"/boot.py\", \"w\") as f:\n        f.write(\"\"\"\\\n# This file is executed on every boot (including wake-boot from deepsleep)\n#import esp\n#esp.osdebug(None)\nimport gc\n#import webrepl\n#webrepl.start()\ngc.collect()\n\"\"\")\n    return vfs\n\0"
"try:\n    import usocket as socket\nexcept:\n    import socket\ntry:\n    import ustruct as struct\nexcept:\n    import struct\n\n# (date(2000, 1, 1) - date(1900, 1, 1)).days * 24*60*60\nNTP_DELTA = 3155673600\n\nhost = \"pool.ntp.org\"\n\ndef time():\n    NTP_QUERY = bytearray(48)\n    NTP_QUERY[0] = 0x1b\n    addr = socket.getaddrinfo(host, 123)[0][-1]\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    s.settimeout(1)\n    res = s.sendto(NTP_QUERY, addr)\n    msg = s.recv(48)\n    s.close()\n    val = struct.unpack(\"!I\", msg[40:44])[0]\n    return val - NTP_DELTA\n\n# There's currently no timezone support in MicroPython, so\n# utime.localtime() will return UTC time (as if it was .gmtime())\ndef settime():\n    t = time()\n    import machine\n    import utime\n    tm = utime.localtime(t)\n    tm = tm[0:3] + (0,) + tm[3:6] + (0,)\n    machine.RTC().datetime(tm)\n    print(utime.localtime())\n\0"
"import main\nmain()\n\0"
};
