#include <stdint.h>
const char mp_frozen_str_names[] = {
"upip_utarfile.py\0"
"upip_gzip.py\0"
"upip.py\0"
"\0"};
const uint32_t mp_frozen_str_sizes[] = {
2050,
560,
7986,
};
const char mp_frozen_str_content[] = {
"import uctypes\n\n# http://www.gnu.org/software/tar/manual/html_node/Standard.html\nTAR_HEADER = {\n    \"name\": (uctypes.ARRAY | 0, uctypes.UINT8 | 100),\n    \"size\": (uctypes.ARRAY | 124, uctypes.UINT8 | 12),\n}\n\nDIRTYPE = \"dir\"\nREGTYPE = \"file\"\n\ndef roundup(val, align):\n    return (val + align - 1) & ~(align - 1)\n\ndef skip(f, size):\n    assert size % 512 == 0\n    buf = bytearray(512)\n    while size:\n        size -= f.readinto(buf)\n\nclass FileSection:\n\n    def __init__(self, f, content_len, aligned_len):\n        self.f = f\n        self.content_len = content_len\n        self.align = aligned_len - content_len\n\n    def read(self, sz=65536):\n        if self.content_len == 0:\n            return b\"\"\n        if sz > self.content_len:\n            sz = self.content_len\n        data = self.f.read(sz)\n        sz = len(data)\n        self.content_len -= sz\n        return data\n\n    def skip(self):\n        self.f.read(self.content_len + self.align)\n\nclass TarInfo:\n\n    def __str__(self):\n        return \"TarInfo(%r, %s, %d)\" % (self.name, self.type, self.size)\n\nclass TarFile:\n\n    def __init__(self, name):\n        self.f = open(name, \"rb\")\n        self.subf = None\n\n    def next(self):\n            if self.subf:\n                self.subf.skip()\n            buf = self.f.read(512)\n            if not buf:\n                return None\n\n            h = uctypes.struct(uctypes.addressof(buf), TAR_HEADER, uctypes.LITTLE_ENDIAN)\n\n            # Empty block means end of archive\n            if h.name[0] == 0:\n                return None\n\n            d = TarInfo()\n            d.name = str(h.name, \"utf-8\").rstrip()\n            d.size = int(bytes(h.size).rstrip(), 8)\n            d.type = [REGTYPE, DIRTYPE][d.name[-1] == \"/\"]\n            self.subf = d.subf = FileSection(self.f, d.size, roundup(d.size, 512))\n            return d\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        v = self.next()\n        if v is None:\n            raise StopIteration\n        return v\n\n    def extractfile(self, tarinfo):\n        return tarinfo.subf\n\0"
"#import zlib\nimport uzlib as zlib\n\nFTEXT    = 1\nFHCRC    = 2\nFEXTRA   = 4\nFNAME    = 8\nFCOMMENT = 16\n\ndef decompress(data):\n    assert data[0] == 0x1f and data[1] == 0x8b\n    assert data[2] == 8\n    flg = data[3]\n    assert flg & 0xe0 == 0\n    i = 10\n    if flg & FEXTRA:\n        i += data[11] << 8 + data[10] + 2\n    if flg & FNAME:\n        while data[i]:\n            i += 1\n        i += 1\n    if flg & FCOMMENT:\n        while data[i]:\n            i += 1\n        i += 1\n    if flg & FHCRC:\n        i += 2\n    return zlib.decompress(memoryview(data)[i:], -15)\n\0"
"def upip_import(mod, sub=None):\n    try:\n        mod_ = mod\n        if sub:\n            mod_ += \"_\" + sub\n        return __import__(\"upip_\" + mod_)\n    except ImportError:\n        m = __import__(mod)\n        if sub:\n            return getattr(m, sub)\n        return m\n\nsys = upip_import(\"sys\")\nimport uos as os\nimport uerrno as errno\n\ngzip = upip_import(\"gzip\")\ntry:\n    tarfile = upip_import(\"utarfile\")\nexcept ImportError:\n    tarfile = upip_import(\"tarfile\")\ntry:\n    json = upip_import(\"ujson\")\nexcept ImportError:\n    json = upip_import(\"json\")\n\n\nDEFAULT_MICROPYPATH = \"~/.micropython/lib:/usr/lib/micropython\"\n\ndebug = False\ncleanup_files = [\".pkg.tar\"]\n\nclass NotFoundError(Exception):\n    pass\n\ndef op_split(path):\n    if path == \"\":\n        return (\"\", \"\")\n    r = path.rsplit(\"/\", 1)\n    if len(r) == 1:\n        return (\"\", path)\n    head = r[0]\n    if not head:\n        head = \"/\"\n    return (head, r[1])\n\ndef op_basename(path):\n    return op_split(path)[1]\n\ndef _makedirs(name, mode=0o777):\n    ret = False\n    s = \"\"\n    for c in name.rstrip(\"/\").split(\"/\"):\n        s += c + \"/\"\n        try:\n            os.mkdir(s)\n            ret = True\n        except OSError as e:\n            if e.args[0] != errno.EEXIST and e.args[0] != errno.EISDIR:\n                raise\n            ret = False\n    return ret\n\n\ndef save_file(fname, subf):\n    outf = open(fname, \"wb\")\n    while True:\n        buf = subf.read(1024)\n        if not buf:\n            break\n        outf.write(buf)\n    outf.close()\n\ndef install_tar(f, prefix):\n    meta = {}\n    for info in f:\n        #print(info)\n        fname = info.name\n        try:\n            fname = fname[fname.index(\"/\") + 1:]\n        except ValueError:\n            fname = \"\"\n\n        save = True\n        for p in (\"setup.\", \"PKG-INFO\", \"README\"):\n                #print(fname, p)\n                if fname.startswith(p) or \".egg-info\" in fname:\n                    if fname.endswith(\"/requires.txt\"):\n                        meta[\"deps\"] = f.extractfile(info).read()\n                    save = False\n                    if debug:\n                        print(\"Skipping\", fname)\n                    break\n\n        if save:\n            outfname = prefix + fname\n            if info.type == tarfile.DIRTYPE:\n                if _makedirs(outfname):\n                    print(\"Created \" + outfname)\n            else:\n                if debug:\n                    print(\"Extracting \" + outfname)\n                subf = f.extractfile(info)\n                save_file(outfname, subf)\n    return meta\n\ndef expandhome(s):\n    h = os.getenv(\"HOME\")\n    s = s.replace(\"~/\", h + \"/\")\n    return s\n\ntry:\n    import ussl\n    import usocket\n    warn_ussl = True\n    def download(url, local_name):\n        global warn_ussl\n        proto, _, host, urlpath = url.split('/', 3)\n        ai = usocket.getaddrinfo(host, 443)\n        #print(\"Address infos:\", ai)\n        addr = ai[0][4]\n\n        s = usocket.socket(ai[0][0])\n        #print(\"Connect address:\", addr)\n        s.connect(addr)\n\n        if proto == \"https:\":\n            s = ussl.wrap_socket(s)\n            if warn_ussl:\n                print(\"Warning: %s SSL certificate is not validated\" % host)\n                warn_ussl = False\n\n        # MicroPython rawsocket module supports file interface directly\n        s.write(\"GET /%s HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n\" % (urlpath, host))\n        l = s.readline()\n        protover, status, msg = l.split(None, 2)\n        if status != b\"200\":\n            raise OSError()\n        while 1:\n            l = s.readline()\n            if not l:\n                raise OSError()\n            if l == b'\\r\\n':\n                break\n        with open(local_name, \"wb\") as f:\n            while 1:\n                l = s.read(1024)\n                if not l:\n                    break\n                f.write(l)\n\nexcept ImportError:\n\n    def download(url, local_name):\n        if debug:\n            print(\"wget -q %s -O %s\" % (url, local_name))\n        rc = os.system(\"wget -q %s -O %s\" % (url, local_name))\n        if local_name not in cleanup_files:\n            cleanup_files.append(local_name)\n        if rc == 8 * 256:\n            raise NotFoundError\n\n\ndef get_pkg_metadata(name):\n    download(\"https://pypi.python.org/pypi/%s/json\" % name, \".pkg.json\")\n    with open(\".pkg.json\") as f:\n        s = f.read()\n    return json.loads(s)\n\n\ndef fatal(msg):\n    print(msg)\n    sys.exit(1)\n\ndef gzdecompress(package_fname):\n    f = open(package_fname, \"rb\")\n    zipdata = f.read()\n    data = gzip.decompress(zipdata)\n    return data\n\ndef gzdecompress_(package_fname):\n    os.system(\"gzip -d -c %s > ungz\" % package_fname)\n    with open(\"ungz\", \"rb\") as f:\n        return f.read()\n\ndef install_pkg(pkg_spec, install_path):\n    data = get_pkg_metadata(pkg_spec)\n\n    latest_ver = data[\"info\"][\"version\"]\n    packages = data[\"releases\"][latest_ver]\n    assert len(packages) == 1\n    package_url = packages[0][\"url\"]\n    print(\"Installing %s %s from %s\" % (pkg_spec, latest_ver, package_url))\n    package_fname = op_basename(package_url)\n    download(package_url, package_fname)\n\n    data = gzdecompress(package_fname)\n\n    f = open(\".pkg.tar\", \"wb\")\n    f.write(data)\n    f.close()\n\n    f = tarfile.TarFile(\".pkg.tar\")\n    return install_tar(f, install_path)\n\ndef cleanup():\n    for fname in cleanup_files:\n        try:\n            os.unlink(fname)\n        except OSError:\n            print(\"Warning: Cannot delete \" + fname)\n\ndef help():\n    print(\"\"\"\\\nupip - Simple PyPI package manager for MicroPython\nUsage: micropython -m upip install [-p <path>] <package>... | -r <requirements.txt>\n\nIf -p is not given, packages will be installed to first path component of\nMICROPYPATH, or to ~/.micropython/lib/ by default.\nNote: only MicroPython packages (usually, micropython-*) are supported for\ninstallation, upip does not support arbitrary code in setup.py.\"\"\")\n    sys.exit(1)\n\ndef main():\n    global debug\n    install_path = None\n\n    if len(sys.argv) < 2 or sys.argv[1] == \"-h\" or sys.argv[1] == \"--help\":\n        help()\n\n    if sys.argv[1] != \"install\":\n        fatal(\"Only 'install' command supported\")\n\n    to_install = []\n\n    i = 2\n    while i < len(sys.argv) and sys.argv[i][0] == \"-\":\n        opt = sys.argv[i]\n        i += 1\n        if opt == \"-h\" or opt == \"--help\":\n            help()\n        elif opt == \"-p\":\n            install_path = sys.argv[i]\n            i += 1\n        elif opt == \"-r\":\n            list_file = sys.argv[i]\n            i += 1\n            with open(list_file) as f:\n                while True:\n                    l = f.readline()\n                    if not l:\n                        break\n                    to_install.append(l.rstrip())\n        elif opt == \"--debug\":\n            debug = True\n        else:\n            fatal(\"Unknown/unsupported option: \" + opt)\n\n    if install_path is None:\n        install_path = os.getenv(\"MICROPYPATH\") or DEFAULT_MICROPYPATH\n\n    install_path = install_path.split(\":\", 1)[0]\n\n    install_path = expandhome(install_path)\n\n    if install_path[-1] != \"/\":\n        install_path += \"/\"\n\n    print(\"Installing to: \" + install_path)\n\n    to_install.extend(sys.argv[i:])\n    if not to_install:\n        help()\n\n    # sets would be perfect here, but don't depend on them\n    installed = []\n    try:\n        while to_install:\n            if debug:\n                print(\"Queue:\", to_install)\n            pkg_spec = to_install.pop(0)\n            if pkg_spec in installed:\n                continue\n            meta = install_pkg(pkg_spec, install_path)\n            installed.append(pkg_spec)\n            if debug:\n                print(meta)\n            deps = meta.get(\"deps\", \"\").rstrip()\n            if deps:\n                deps = deps.decode(\"utf-8\").split(\"\\n\")\n                to_install.extend(deps)\n    except NotFoundError:\n        print(\"Error: cannot find '%s' package (or server error), packages may be partially installed\" \\\n            % pkg_spec, file=sys.stderr)\n\n    if not debug:\n        cleanup()\n\nmain()\n\0"
};
